pub f32 PI = 3.14159265359
pub f32 E = 2.71828182846
pub i32 MAX_INT = 2147483647
pub i32 MIN_INT = -2147483648
pub f32 TAU = 6.28318530718
pub f32 PHI = 1.61803398875 

pub fn to_int(string value) -> i32:
    i32 i = 0
    i32 result = 0
    i32 sign = 1
    i32 len = len(value)

    while i < len and (value[i] == ' ' or value[i] == '\t' or value[i] == '\n'):
        i = i + 1
    if i < len and value[i] == '-':
        sign = -1
        i = i + 1
    elif i < len and value[i] == '+':
        i = i + 1
    while i < len and value[i] >= '0' and value[i] <= '9':
        result = result * 10 + (ord(value[i]) - ord('0'))
        i = i + 1

    return result * sign

pub fn to_float(string value) -> f32:
    i32 i = 0
    f32 result = 0.0
    i32 sign = 1
    f32 fraction = 0.0
    f32 divisor = 10.0
    i32 len = len(value)

    while i < len and (value[i] == ' ' or value[i] == '\t' or value[i] == '\n'):
        i = i + 1
        if i < len and value[i] == '-':
            sign = -1
            i = i + 1
        elif i < len and value[i] == '+':
            i = i + 1

    while i < len and value[i] >= '0' and value[i] <= '9':
        result = (result * 10.0) + float(ord(value[i]) - ord('0'))
        i = i + 1

    if i < len and value[i] == '.':
        i = i + 1
        while i < len and value[i] >= '0' and value[i] <= '9':
            fraction = fraction + (float(ord(value[i]) - ord('0')) / divisor)
            divisor = divisor * 10.0
            i = i + 1

    return float(sign) * (result + fraction)

pub fn min(i32 a, i32 b) -> i32:
    if a < b:
        return a
    return b

pub fn max(i32 a, i32 b) -> i32:
    if a > b:
        return a
    return b

pub fn absolute(f32 value) -> f32:
    if value < 0.0:
        return -value
    return value

pub fn pow(f32 base, i32 exp) -> f32:
    f32 result = 1.0
    i32 i = 0
    if exp < 0:
        return 1.0 / math::pow(base, -exp)
    for i = 0 to exp - 1:
        result = result * base
    return result

pub fn factorial(i32 n) -> i32:
    if n < 0:
        return -1
    i32 result = 1
    for i = 2 to n:
        result = result * i
    return result

pub fn clamp(f32 value, f32 min_value, f32 max_value) -> f32:
    if value < min_value:
        return min_value
    elif value > max_value:
        return max_value
    return value

pub fn normalize(f32 x) -> f32:
    while x > math::PI:
        x = x - 2.0 * math::PI
    while x < -math::PI:
        x = x + 2.0 * math::PI
    return x

pub fn sin(f32 x) -> f32:
    x = math::normalize(x)
    f32 term = x
    f32 result = x
    f32 x_squared = x * x
    i32 i = 1
    i32 sign = -1
    while i < 10:
        term = term * x_squared / float((2 * i) * (2 * i + 1))
        result = result + float(sign) * term
        sign = -sign
        i = i + 1
    return result

pub fn cos(f32 x) -> f32:
    x = math::normalize(x)
    f32 term = 1.0
    f32 result = 1.0
    f32 x_squared = x * x
    i32 i = 1
    i32 sign = -1
    while i < 10:
        term = term * x_squared / float((2 * i - 1) * (2 * i))
        result = result + float(sign) * term
        sign = -sign
        i = i + 1
    return result

## Will return 0.0 if cos(x) is too close to 0.0
pub fn tan(f32 x) -> f32:
    f32 cos_x = math::cos(x)
    if math::absolute(cos_x) < 0.00001:
        return 0.0
    return math::sin(x) / cos_x

pub fn exp(f32 x) -> f32:
    f32 sum = 1.0
    f32 term = 1.0
    i32 i = 1
    while i < 20:
        term = term * x / float(i)
        sum = sum + term
        i = i + 1
    return sum

## Will return -1.0 if x <= 0.0
pub fn ln(f32 x) -> f32:
    if x <= 0.0:
        return -1.0
    f32 y = (x - 1) / (x + 1)
    f32 y2 = y * y
    f32 sum = 0.0
    f32 term = y
    i32 i = 1
    while i < 20:
        sum = sum + term / float(2 * i - 1)
        term = term * y2
        i = i + 1
    return 2.0 * sum

## Will return 0.0 if x < -1.0 || x > 1.0
pub fn asin(f32 x) -> f32:
    if x < -1.0 || x > 1.0:
        return 0.0
    f32 result = 0.0
    f32 term = x
    f32 x2 = x * x
    i32 i = 0
    i32 sign = 1
    while i < 10:
        result = result + float(sign) * term / (2 * i + 1)
        term = term * x2 * float((2 * i + 1)*(2 * i + 1)) / float((2 * i + 2)*(2 * i + 3))
        sign = -sign
        i = i + 1
    return result

pub fn acos(float x) -> float:
    if x < -1.0 or x > 1.0:
        return 0.0
    if x == 1.0:
        return 0.0
    if x == -1.0:
        return math::PI
    return math::PI / 2 - math::asin(x)

pub fn atan(float x) -> float:
    if x == 0.0:
        return 0.0
    if math::absolute(x) > 1.0:
        float result = math::PI / 2 - math::atan(1 / x)
        if x < 0.0:
            result = result - math::PI
        return result
    float term = x
    float result = x
    float x2 = x * x
    int i = 1
    int sign = -1
    while i < 10:
        term = term * x2
        result = result + float(sign) * term / (2 * i + 1)
        sign = -sign
        i = i + 1
    return result

pub fn round(float value, int decimalPlaces) -> float:
    float factor = math::pow(10.0, float(decimalPlaces))
    return (float)((int)(value * factor + 0.5)) / factor

## Print float with specified number of decimal places without trailing zeroes
## e.g. run math::print_float(3.14159265359, 2)
pub fn print_float(float value, int decimalPlaces) -> void:
    put "%.*f" | decimalPlaces, math::round(value, decimalPlaces)

pub fn mod(float a, float b) -> float:
    if b == 0.0:
        return 0.0 
    float result = a - b * math::floor(a / b)
    return result

pub fn floor(float x) -> float:
    int i = (int)x
    if float(i) > x:
        return float(i - 1)
    return float(i)

pub fn ceil(float x) -> float:
    int i = (int)x
    if float(i) < x:
        return float(i + 1)
    return float(i)

pub fn log_base(float x, float base) -> float:
    if x <= 0.0 or base <= 0.0 or base == 1.0:
        return -1.0
    return math::ln(x) / math::ln(base)
